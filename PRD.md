# Product Requirements Document: RecurringThings Library

## Document Information
- **Product Name**: RecurringThings
- **Version**: 1.1
- **Target Framework**: .NET 10.0
- **Document Status**: Draft
- **Last Updated**: January 27, 2026

---

## 1. Executive Summary

### 1.1 Product Overview
RecurringThings is a .NET library that provides a robust, database-agnostic solution for managing recurring events, appointments, and time-based entries. The library virtualizes recurring patterns on-demand rather than materializing all future instances, enabling efficient querying and manipulation of calendar-like data with support for time zones, daylight saving time, exceptions, and overrides.

### 1.2 Target Audience
- .NET developers building calendar systems
- SaaS applications requiring multi-tenant scheduling
- Enterprise applications managing recurring workflows
- Systems handling appointments, service hours, or recurring tasks

### 1.3 Core Value Proposition
- **On-demand virtualization**: Generate recurring instances only when queried, not stored
- **Multi-tenant isolation**: Built-in organization and resource path scoping
- **Database flexibility**: Pluggable persistence with MongoDB and PostgreSQL implementations
- **Transaction support**: Integration with Transactional library for ACID operations
- **Time zone correctness**: Proper DST handling using IANA time zones and NodaTime

---

## 2. Product Architecture

### 2.1 Package Structure

The product consists of three NuGet packages:

#### 2.1.1 RecurringThings (Core)
- **Purpose**: Core virtualization engine and abstractions
- **Dependencies**: 
  - NodaTime (time zone handling)
  - Ical.Net (RRule parsing)
  - Transactional.Abstractions
- **Exports**:
  - `IRecurrenceEngine` interface
  - Domain models (CalendarEntry, Recurrence, Occurrence, etc.)
  - Repository abstractions
  - Validation logic

#### 2.1.2 RecurringThings.MongoDB
- **Purpose**: MongoDB persistence implementation
- **Dependencies**:
  - RecurringThings (core)
  - MongoDB.Driver 3.x
  - Transactional.MongoDB
- **Exports**:
  - MongoDB repository implementations
  - DI extension methods
  - Migration logic

#### 2.1.3 RecurringThings.PostgreSQL
- **Purpose**: PostgreSQL persistence implementation
- **Dependencies**:
  - RecurringThings (core)
  - Npgsql 8.x
  - Transactional.PostgreSQL
- **Exports**:
  - PostgreSQL repository implementations
  - DI extension methods
  - Migration scripts

### 2.2 Dependency Flow
```
RecurringThings.MongoDB ──→ RecurringThings (core)
                              ↓
RecurringThings.PostgreSQL ──→ Transactional.Abstractions
```

---

## 3. Domain Model

### 3.1 Core Entities

#### 3.1.1 Recurrence

| Field | Type | Nullable | Min | Max | Description |
|-------|------|----------|-----|-----|-------------|
| `Id` | `Guid` | No | - | - | Primary key, generated by library |
| `Organization` | `string` | No | 0 | 100 | Tenant identifier for multi-tenant isolation |
| `ResourcePath` | `string` | No | 0 | 100 | Hierarchical resource scope (e.g., "user123/calendar") |
| `Type` | `string` | No | 1 | 100 | User-defined type (e.g., "appointment", "open-hours") |
| `StartTime` | `DateTime` | No | - | - | UTC timestamp representing the time-of-day that occurrences start |
| `Duration` | `TimeSpan` | No | - | - | Duration of each occurrence |
| `RecurrenceEndTime` | `DateTime` | No | - | - | UTC timestamp when recurrence series ends (must match RRule UNTIL) |
| `RRule` | `string` | No | 1 | 2000 | RFC 5545 recurrence rule (must use UNTIL in UTC, COUNT not supported) |
| `TimeZone` | `string` | No | 1 | 100 | IANA time zone identifier |
| `Extensions` | `Dictionary<string, string>` | Yes | - | - | User-defined key-value data (key min 1 max 100, value max 1024) |

**Note**: Recurrences do not store an `EndTime` field. Query filtering uses `StartTime` and `RecurrenceEndTime` only. The end time of individual virtualized occurrences is computed dynamically as `occurrenceStartTime + Duration`.

#### 3.1.2 Occurrence

| Field | Type | Nullable | Min | Max | Description |
|-------|------|----------|-----|-----|-------------|
| `Id` | `Guid` | No | - | - | Primary key, generated by library |
| `Organization` | `string` | No | 0 | 100 | Tenant identifier |
| `ResourcePath` | `string` | No | 0 | 100 | Hierarchical resource scope |
| `Type` | `string` | No | 1 | 100 | User-defined type |
| `StartTime` | `DateTime` | No | - | - | UTC timestamp |
| `EndTime` | `DateTime` | No | - | - | UTC timestamp computed from StartTime + Duration |
| `Duration` | `TimeSpan` | No | - | - | Duration |
| `TimeZone` | `string` | No | 1 | 100 | IANA time zone identifier |
| `Extensions` | `Dictionary<string, string>` | Yes | - | - | User-defined key-value data |

#### 3.1.3 OccurrenceException

| Field | Type | Nullable | Min | Max | Description |
|-------|------|----------|-----|-----|-------------|
| `Id` | `Guid` | No | - | - | Primary key, generated by library |
| `Organization` | `string` | No | 0 | 100 | Tenant identifier |
| `ResourcePath` | `string` | No | 0 | 100 | Hierarchical resource scope |
| `RecurrenceId` | `Guid` | No | - | - | Foreign key to parent recurrence |
| `OriginalTimeUtc` | `DateTime` | No | - | - | UTC timestamp of occurrence to cancel |
| `Extensions` | `Dictionary<string, string>` | Yes | - | - | User-defined key-value data |

#### 3.1.4 OccurrenceOverride

| Field | Type | Nullable | Min | Max | Description |
|-------|------|----------|-----|-----|-------------|
| `Id` | `Guid` | No | - | - | Primary key, generated by library |
| `Organization` | `string` | No | 0 | 100 | Tenant identifier |
| `ResourcePath` | `string` | No | 0 | 100 | Hierarchical resource scope |
| `RecurrenceId` | `Guid` | No | - | - | Foreign key to parent recurrence |
| `OriginalTimeUtc` | `DateTime` | No | - | - | UTC timestamp of occurrence being replaced |
| `StartTime` | `DateTime` | No | - | - | New UTC timestamp |
| `EndTime` | `DateTime` | No | - | - | New UTC timestamp computed from StartTime + Duration |
| `Duration` | `TimeSpan` | No | - | - | New duration |
| `OriginalDuration` | `TimeSpan` | No | - | - | Original duration (denormalized from recurrence at creation) |
| `OriginalExtensions` | `Dictionary<string, string>` | Yes | - | - | Original extensions (denormalized from recurrence at creation) |
| `Extensions` | `Dictionary<string, string>` | Yes | - | - | User-defined key-value data |

### 3.2 Query Result Models

#### 3.2.1 CalendarEntry
Unified abstraction returned from queries, representing recurrences, standalone occurrences, or virtualized occurrences.

```csharp
public class CalendarEntry
{
    // Common fields
    public string Organization { get; set; }
    public string ResourcePath { get; set; }
    public string Type { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public TimeSpan Duration { get; set; }
    public string TimeZone { get; set; }
    public Dictionary<string, string>? Extensions { get; set; }
    
    // Type-specific IDs (all nullable - exactly one will be set based on entry type)
    public Guid? RecurrenceId { get; set; }      // Set for recurrence entries
    public Guid? OccurrenceId { get; set; }      // Set for standalone occurrence entries
    public Guid? OverrideId { get; set; }        // Set for overridden recurrence occurrences
    public Guid? ExceptionId { get; set; }       // Never set in query results (excepted occurrences are not returned)
    
    // Type-specific details (mutually exclusive)
    public RecurrenceDetails? RecurrenceDetails { get; set; }
    public RecurrenceOccurrenceDetails? RecurrenceOccurrenceDetails { get; set; }
    
    // If both null → Standalone occurrence (OccurrenceId will be set)
}
```

#### 3.2.2 RecurrenceDetails
Present when `CalendarEntry` represents a recurrence pattern.

```csharp
public class RecurrenceDetails
{
    public DateTime RecurrenceEndTime { get; set; }
    public string RRule { get; set; }
}
```

#### 3.2.3 RecurrenceOccurrenceDetails
Present when `CalendarEntry` represents an occurrence generated from a recurrence.

```csharp
public class RecurrenceOccurrenceDetails
{
    public Guid RecurrenceId { get; set; }
    public OccurrenceOriginal? Original { get; set; }  // Non-null if override applied
}
```

#### 3.2.4 OccurrenceOriginal
Contains original values before an override was applied.

```csharp
public class OccurrenceOriginal
{
    public DateTime StartTime { get; set; }
    public TimeSpan Duration { get; set; }
    public Dictionary<string, string>? Extensions { get; set; }
}
```

### 3.3 Request Models

#### 3.3.1 RecurrenceCreate
```csharp
public class RecurrenceCreate
{
    public required string Organization { get; init; }
    public required string ResourcePath { get; init; }
    public required string Type { get; init; }
    public required DateTime StartTimeUtc { get; init; }
    public required TimeSpan Duration { get; init; }
    public required DateTime RecurrenceEndTimeUtc { get; init; }
    public required string RRule { get; init; }
    public required string TimeZone { get; init; }
    public Dictionary<string, string>? Extensions { get; init; }
}
```

#### 3.3.2 OccurrenceCreate
```csharp
public class OccurrenceCreate
{
    public required string Organization { get; init; }
    public required string ResourcePath { get; init; }
    public required string Type { get; init; }
    public required DateTime StartTimeUtc { get; init; }
    public required TimeSpan Duration { get; init; }
    public required string TimeZone { get; init; }
    public Dictionary<string, string>? Extensions { get; init; }
}
```

---

## 4. Public API

### 4.1 Primary Interface: IRecurrenceEngine

```csharp
public interface IRecurrenceEngine
{
    /// <summary>
    /// Retrieves all calendar entries (recurrences, standalone occurrences, and 
    /// virtualized occurrences) within the specified time range.
    /// Excepted (deleted) virtualized occurrences are not returned.
    /// Results are streamed via IAsyncEnumerable to avoid materializing large result sets.
    /// </summary>
    IAsyncEnumerable<CalendarEntry> GetAsync(
        string organization,
        string resourcePath,
        DateTime startUtc,
        DateTime endUtc,
        string[]? types = null,
        [EnumeratorCancellation] CancellationToken cancellationToken = default
    );

    /// <summary>
    /// Creates a new recurrence pattern.
    /// </summary>
    /// <returns>Created recurrence with generated Id</returns>
    Task<Recurrence> CreateRecurrenceAsync(
        RecurrenceCreate request,
        ITransactionContext? transactionContext = null,
        CancellationToken cancellationToken = default
    );

    /// <summary>
    /// Creates a new standalone occurrence.
    /// </summary>
    /// <returns>Created occurrence with generated Id</returns>
    Task<Occurrence> CreateOccurrenceAsync(
        OccurrenceCreate request,
        ITransactionContext? transactionContext = null,
        CancellationToken cancellationToken = default
    );

    /// <summary>
    /// Updates a calendar entry. Behavior depends on entry type:
    /// - Recurrence: Updates Duration and Extensions only
    /// - Standalone occurrence: Updates StartTime, Duration, and Extensions only
    /// - Recurrence occurrence: Creates or updates an override
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// Thrown when attempting to modify immutable fields
    /// </exception>
    Task<CalendarEntry> UpdateAsync(
        CalendarEntry entry,
        ITransactionContext? transactionContext = null,
        CancellationToken cancellationToken = default
    );

    /// <summary>
    /// Deletes a calendar entry. Behavior depends on entry type:
    /// - Recurrence: Deletes entire series including all exceptions and overrides
    /// - Standalone occurrence: Deletes the occurrence
    /// - Recurrence occurrence: Creates an exception (and removes override if present)
    /// </summary>
    Task DeleteAsync(
        CalendarEntry entry,
        ITransactionContext? transactionContext = null,
        CancellationToken cancellationToken = default
    );

    /// <summary>
    /// Restores a recurrence occurrence by removing its override.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// Thrown when called on a recurrence, standalone occurrence, or 
    /// recurrence occurrence without an override
    /// </exception>
    Task RestoreAsync(
        CalendarEntry entry,
        ITransactionContext? transactionContext = null,
        CancellationToken cancellationToken = default
    );
}
```

### 4.2 Service Registration

#### 4.2.1 MongoDB Configuration
```csharp
services.AddRecurringThings(cfg =>
{
    cfg.UseMongoDb(mongo =>
    {
        mongo.ConnectionString = "mongodb://localhost:27017";
        mongo.DatabaseName = "MyApplication";  // Required
        mongo.CollectionName = "recurring_things";  // Optional, default: "recurring_things"
    });
});
```

#### 4.2.2 PostgreSQL Configuration
```csharp
services.AddRecurringThings(cfg =>
{
    cfg.UsePostgreSQL(pg =>
    {
        pg.ConnectionString = "Host=localhost;Database=myapp;Username=user;Password=pass";
        pg.SchemaName = "public";  // Optional, default: "public"
    });
});
```

### 4.3 Configuration Rules
- **Exactly one persistence provider required**: Application fails at startup if neither or both MongoDB and PostgreSQL are configured
- **MongoDB**: `DatabaseName` is required, `CollectionName` is optional
- **PostgreSQL**: Database must exist, schema is auto-created if missing
- **Transaction managers**: Automatically registered by `UseMongoDb()` and `UsePostgreSQL()` via Transactional library integration

---

## 5. Functional Requirements

### 5.1 Multi-Tenancy

#### 5.1.1 Organization Isolation
- **Requirement**: All operations must be scoped to an `Organization` identifier
- **Purpose**: Enable multi-tenant SaaS applications with data isolation
- **Implementation**: 
  - Organization is mandatory on all entities (non-null, 0-100 characters)
  - MongoDB: Organization is first field in compound shard key
  - PostgreSQL: Organization is first column in composite indexes
  - Empty string is allowed for single-tenant scenarios

#### 5.1.2 Resource Path Scoping
- **Requirement**: All operations must be scoped to a `ResourcePath` identifier
- **Purpose**: Enable hierarchical resource organization (e.g., "user123/calendar", "store456")
- **Implementation**:
  - ResourcePath is mandatory on all entities (non-null, 0-100 characters)
  - Freeform string, no format validation
  - Exact match filtering only (no prefix/wildcard queries in v1.0)
  - Empty string is allowed

#### 5.1.3 Exception/Override Tenant Validation
- **Requirement**: Exceptions and overrides must belong to the same Organization and ResourcePath as their parent recurrence
- **Implementation**:
  - Core library validates on creation:
    ```csharp
    var recurrence = await _recurrenceRepo.GetByIdAsync(request.RecurrenceId);
    if (recurrence == null)
        throw new ArgumentException("Recurrence not found");
    if (recurrence.Organization != request.Organization || 
        recurrence.ResourcePath != request.ResourcePath)
        throw new InvalidOperationException("Cannot create exception/override for recurrence in different scope");
    ```

### 5.2 Type-Based Filtering

#### 5.2.1 Type Field
- **Requirement**: Recurrences and occurrences must have a user-defined `Type` field
- **Purpose**: Enable differentiation between different kinds of recurring things (appointments, open hours, service offerings, etc.)
- **Implementation**:
  - Type is mandatory (non-null, 1-100 characters)
  - Freeform string, no predefined values
  - Empty string is NOT allowed

#### 5.2.2 Type Filtering
- **Requirement**: `GetAsync()` must support filtering by one or more types
- **Implementation**:
  - `types` parameter accepts `string[]?`
  - `null`: Return all types
  - `[]`: Throw `ArgumentException` (invalid)
  - `["type1", "type2"]`: Return entries matching any of the specified types (IN clause)

### 5.3 Virtualization Logic

#### 5.3.1 On-Demand Generation
- **Requirement**: Recurrence instances must be generated on-demand during queries, not pre-materialized
- **Implementation**:
  - Query recurrences whose series intersect with query range (using StartTime and RecurrenceEndTime)
  - Convert UTC to local time using IANA time zone
  - Apply RRule using Ical.Net to generate theoretical instances
  - Convert instances back to UTC
  - Apply exceptions and overrides
  - Filter by query range and RecurrenceEndTime

#### 5.3.2 Exception Handling
- **Requirement**: Exceptions must cancel specific instances of a recurrence
- **Implementation**:
  - Exception matches instance by `OriginalTimeUtc` (UTC)
  - Matched instance is excluded from query results entirely
  - Excepted occurrences are never returned by `GetAsync()`

#### 5.3.3 Override Handling
- **Requirement**: Overrides must replace specific instances with modified time/duration/extensions
- **Implementation**:
  - Override matches instance by `OriginalTimeUtc` (UTC)
  - Matched instance is replaced with override values
  - `Original` property in CalendarEntry contains pre-override values (denormalized on override)
  - Override is included if either:
    - `OriginalTimeUtc` falls within query range (to suppress virtualized instance), OR
    - Override's time range [StartTime, EndTime] overlaps with query range (to show the moved occurrence)

#### 5.3.4 Override Query Logic
When processing overrides:
- If override's `OriginalTimeUtc` is in range: suppress the virtualized instance, show override instead (if override's time range overlaps with query range)
- If override's `OriginalTimeUtc` is outside range but override's time range [StartTime, EndTime] overlaps with query range: show override (no virtualized instance to suppress)
- If override's time range is outside query range but `OriginalTimeUtc` is in range: suppress virtualized instance, don't show override

#### 5.3.5 Exception and Override Precedence
- **Constraint**: An occurrence cannot have both an exception and an override simultaneously
- **Validation**: Core library must prevent this illegal state

### 5.4 Immutability Rules

#### 5.4.1 Recurrence Immutable Fields
After creation, the following fields cannot be modified:
- `Organization`
- `ResourcePath`
- `Type`
- `TimeZone`
- `StartTime`
- `RRule`
- `RecurrenceEndTime`

To change any of these, delete and recreate the recurrence.

#### 5.4.2 Recurrence Mutable Fields
- `Duration`
- `Extensions`

#### 5.4.3 Standalone Occurrence Immutable Fields
- `Organization`
- `ResourcePath`
- `Type`
- `TimeZone`

#### 5.4.4 Standalone Occurrence Mutable Fields
- `StartTime`
- `Duration`
- `Extensions`

**Note**: When `StartTime` or `Duration` is modified on a standalone occurrence, `EndTime` must be recomputed as `StartTime + Duration`.

#### 5.4.5 Override Fields
Overrides inherit `TimeZone` from parent recurrence (not stored separately). Mutable fields:
- `StartTime`
- `Duration`
- `Extensions`

**Note**: When `StartTime` or `Duration` is modified on an override, `EndTime` must be recomputed as `StartTime + Duration`.

### 5.5 State Transition Rules

#### 5.5.1 Update Operations
| Entry Type | Has Override | Allowed | Behavior |
|------------|--------------|---------|----------|
| Recurrence | N/A | Yes | Update Duration/Extensions only |
| Standalone | N/A | Yes | Update StartTime/Duration/Extensions, recompute EndTime |
| Recurrence Occurrence | No | Yes | Create override (denormalize original values) |
| Recurrence Occurrence | Yes | Yes | Update override, recompute EndTime |

#### 5.5.2 Delete Operations
| Entry Type | Has Override | Allowed | Behavior |
|------------|--------------|---------|----------|
| Recurrence | N/A | Yes | Delete series + all exceptions/overrides |
| Standalone | N/A | Yes | Direct delete |
| Recurrence Occurrence | No | Yes | Create exception |
| Recurrence Occurrence | Yes | Yes | Delete override, create exception at original time |

#### 5.5.3 Restore Operations
| Entry Type | Has Override | Allowed | Behavior |
|------------|--------------|---------|----------|
| Recurrence | N/A | **No** | Throw `InvalidOperationException` |
| Standalone | N/A | **No** | Throw `InvalidOperationException` |
| Recurrence Occurrence | No | **No** | Throw `InvalidOperationException` |
| Recurrence Occurrence | Yes | Yes | Delete override |

**Note**: Restoring excepted occurrences is not supported. Once an occurrence is deleted (excepted), it cannot be restored through the API since excepted occurrences are not returned by `GetAsync()`.

### 5.6 RRule Validation

#### 5.6.1 UNTIL Required, COUNT Not Supported
- **Requirement**: RRule must specify UNTIL; COUNT is not supported
- **Rationale**: COUNT prevents efficient query range filtering since the recurrence end time cannot be determined without full virtualization
- **Implementation**:
  ```csharp
  var parsed = ParseRRule(request.RRule);
  
  if (parsed.Count != null)
      throw new ArgumentException("RRule with COUNT is not supported. Use UNTIL instead.");
  
  if (parsed.Until == null)
      throw new ArgumentException("RRule must specify UNTIL.");
  ```

#### 5.6.2 UNTIL Must Be UTC
- **Requirement**: RRule UNTIL must be specified in UTC (Z suffix) to eliminate DST ambiguity
- **Rationale**: Local-time UNTIL values can map to two different UTC times during DST fall-back transitions
- **Implementation**:
  ```csharp
  var parsed = ParseRRule(request.RRule);
  
  if (!parsed.Until.HasTimeZone || !parsed.Until.IsUtc)
      throw new ArgumentException("RRule UNTIL must be specified in UTC (Z suffix).");
  
  var untilUtc = parsed.Until.ToDateTimeUtc();
  
  if (request.RecurrenceEndTimeUtc != untilUtc)
      throw new ArgumentException("RecurrenceEndTimeUtc must match RRule UNTIL.");
  ```

### 5.7 Extensibility

#### 5.7.1 Extensions Dictionary
- **Requirement**: Users must be able to store custom key-value data on all entities
- **Implementation**:
  - `Dictionary<string, string>?` (nullable)
  - Key: Non-null, min 1 character, max 100 characters
  - Value: Non-null, max 1024 characters
  - Validation in core library
  - MongoDB: Embedded document
  - PostgreSQL: JSONB column on each table

### 5.8 Time Zone Handling

#### 5.8.1 UTC Storage
- **Requirement**: All `DateTime` fields must be stored in UTC
- **Implementation**:
  - User provides UTC timestamps
  - No timezone conversion on storage/retrieval
  - Library does not validate or enforce UTC (trusts caller)

#### 5.8.2 IANA Time Zones
- **Requirement**: Recurrences and occurrences must use IANA time zone identifiers
- **Implementation**:
  - Stored as string (e.g., "America/New_York")
  - Validated by NodaTime during virtualization
  - Used for local time conversion when applying RRules

#### 5.8.3 DST Handling
- **Requirement**: Virtualization must correctly handle daylight saving time transitions
- **Implementation**:
  - Convert UTC to local time using NodaTime
  - Apply RRule in local time
  - Convert results back to UTC
  - Ical.Net handles DST edge cases

### 5.9 EndTime Computation and Storage

#### 5.9.1 Computed EndTime Field
- **Requirement**: Standalone occurrences and overrides must store a computed EndTime
- **Purpose**: Enable efficient database queries that filter by both start and end time ranges
- **Implementation**:
  - EndTime = StartTime + Duration
  - Computed and stored at creation time
  - Recomputed when StartTime or Duration is updated
  - Used in database queries to efficiently filter entries that overlap with query range

#### 5.9.2 Recurrences Do Not Store EndTime
- **Requirement**: Recurrences do not store an EndTime field
- **Rationale**: The recurrence's `StartTime` represents the time-of-day for occurrences, not when the series starts. Query filtering uses `StartTime` and `RecurrenceEndTime` to determine if the series potentially overlaps with the query range. Individual occurrence end times are computed dynamically during virtualization.

#### 5.9.3 Query Range Filtering
- **Requirement**: GetAsync must efficiently query entries that overlap with the requested range
- **Implementation**:
  - Standalone occurrences/overrides: `StartTime <= queryEndUtc AND EndTime >= queryStartUtc`
  - Recurrences: `StartTime <= queryEndUtc AND RecurrenceEndTime >= queryStartUtc`

---

## 6. Database Implementation

### 6.1 MongoDB

#### 6.1.1 Collection Schema
**Single collection design** (default name: `recurring_things`)

```javascript
{
  "_id": "guid",
  "organization": "tenant1",
  "resourcePath": "user123/calendar",
  "type": "appointment",
  "documentType": "recurrence",  // "recurrence" | "occurrence" | "exception" | "override"
  "startTime": ISODate("2025-01-15T14:00:00Z"),
  "endTime": ISODate("2025-01-15T15:00:00Z"),  // Not present on recurrences
  "duration": NumberLong(3600000),  // Stored as milliseconds
  "timeZone": "America/New_York",
  
  // Recurrence-specific (null for others)
  "recurrenceEndTime": ISODate("2025-12-31T23:59:59Z"),
  "rRule": "FREQ=DAILY;BYDAY=MO,TU,WE,TH,FR;UNTIL=20251231T235959Z",
  
  // Override/Exception-specific (null for others)
  "recurrenceId": "guid",
  "originalTimeUtc": ISODate("2025-01-20T14:00:00Z"),
  
  // Override-specific denormalized original values
  "originalDuration": NumberLong(3600000),  // Stored as milliseconds
  "originalExtensions": { "title": "Original Title" },
  
  "extensions": {
    "title": "Team Standup",
    "location": "Conference Room A"
  }
}
```

#### 6.1.2 Indexes

**Index 1: For recurrences and occurrences**
```javascript
{ organization: 1, resourcePath: 1, documentType: 1, type: 1, startTime: 1, endTime: 1 }
```

**Index 2: For exceptions/overrides by originalTimeUtc**
```javascript
{ organization: 1, resourcePath: 1, documentType: 1, originalTimeUtc: 1 }
```

**Index 3: For exceptions/overrides by startTime (moved occurrences)**
```javascript
{ organization: 1, resourcePath: 1, documentType: 1, startTime: 1, endTime: 1 }
```

**Index 4: For cascade deletes by recurrenceId**
```javascript
{ organization: 1, recurrenceId: 1 }
```

#### 6.1.3 Query Strategy
Execute two queries in parallel:
1. Recurrences and occurrences using Index 1
2. Exceptions and overrides using Index 2 and Index 3

```csharp
var recurrencesTask = collection.Find(recurrenceOccurrenceFilter).ToListAsync();
var exceptionsOverridesTask = collection.Find(exceptionOverrideFilter).ToListAsync();
await Task.WhenAll(recurrencesTask, exceptionsOverridesTask);
```

#### 6.1.4 Cascade Delete
When deleting a recurrence, exceptions and overrides must be deleted within a transaction to ensure atomicity:

```csharp
await using var session = await client.StartSessionAsync();
session.StartTransaction();
try
{
    // Delete the recurrence
    await collection.DeleteOneAsync(session, recurrenceFilter);
    
    // Delete all related exceptions and overrides
    await collection.DeleteManyAsync(session, Builders<BsonDocument>.Filter.And(
        Builders<BsonDocument>.Filter.Eq("organization", organization),
        Builders<BsonDocument>.Filter.Eq("recurrenceId", recurrenceId),
        Builders<BsonDocument>.Filter.In("documentType", new[] { "exception", "override" })
    ));
    
    await session.CommitTransactionAsync();
}
catch
{
    await session.AbortTransactionAsync();
    throw;
}
```

**Important**: Recurrence deletion with cascade MUST use a transaction to ensure atomicity and prevent orphaned exception/override documents.

#### 6.1.5 Sharding Configuration
- **Shard key**: `{ organization: 1 }`
- **Purpose**: Enable horizontal scaling across tenants
- **Query pattern**: All queries filter by organization first

#### 6.1.6 Auto-Migration
- **Strategy**: Create indexes on first operation if missing
- **Implementation**: Check index existence, create if needed
- **No explicit migration API**: Automatic on startup

### 6.2 PostgreSQL

#### 6.2.1 Table Schema

**recurrences**
```sql
CREATE TABLE recurrences (
    id UUID PRIMARY KEY,
    organization VARCHAR(100) NOT NULL,
    resource_path VARCHAR(100) NOT NULL,
    type VARCHAR(100) NOT NULL,
    start_time TIMESTAMP NOT NULL,
    duration INTERVAL NOT NULL,
    recurrence_end_time TIMESTAMP NOT NULL,
    r_rule VARCHAR(2000) NOT NULL,
    time_zone VARCHAR(100) NOT NULL,
    extensions JSONB
);
```

**occurrences**
```sql
CREATE TABLE occurrences (
    id UUID PRIMARY KEY,
    organization VARCHAR(100) NOT NULL,
    resource_path VARCHAR(100) NOT NULL,
    type VARCHAR(100) NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    duration INTERVAL NOT NULL,
    time_zone VARCHAR(100) NOT NULL,
    extensions JSONB
);
```

**occurrence_exceptions**
```sql
CREATE TABLE occurrence_exceptions (
    id UUID PRIMARY KEY,
    organization VARCHAR(100) NOT NULL,
    resource_path VARCHAR(100) NOT NULL,
    recurrence_id UUID NOT NULL,
    original_time_utc TIMESTAMP NOT NULL,
    extensions JSONB,
    FOREIGN KEY (recurrence_id) REFERENCES recurrences(id) ON DELETE CASCADE
);
```

**occurrence_overrides**
```sql
CREATE TABLE occurrence_overrides (
    id UUID PRIMARY KEY,
    organization VARCHAR(100) NOT NULL,
    resource_path VARCHAR(100) NOT NULL,
    recurrence_id UUID NOT NULL,
    original_time_utc TIMESTAMP NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    duration INTERVAL NOT NULL,
    original_duration INTERVAL NOT NULL,
    original_extensions JSONB,
    extensions JSONB,
    FOREIGN KEY (recurrence_id) REFERENCES recurrences(id) ON DELETE CASCADE
);
```

#### 6.2.2 Indexes
```sql
-- Composite indexes for query optimization
CREATE INDEX idx_recurrences_query 
ON recurrences(organization, resource_path, type, start_time, recurrence_end_time);

CREATE INDEX idx_occurrences_query 
ON occurrences(organization, resource_path, type, start_time, end_time);

-- Exception lookups
CREATE INDEX idx_exceptions_query
ON occurrence_exceptions(organization, resource_path, original_time_utc);

-- Override lookups (by original time OR new time)
CREATE INDEX idx_overrides_original
ON occurrence_overrides(organization, resource_path, original_time_utc);

CREATE INDEX idx_overrides_start
ON occurrence_overrides(organization, resource_path, start_time, end_time);

-- Foreign key indexes
CREATE INDEX idx_exceptions_recurrence 
ON occurrence_exceptions(recurrence_id);

CREATE INDEX idx_overrides_recurrence 
ON occurrence_overrides(recurrence_id);
```

#### 6.2.3 Cascade Delete
PostgreSQL uses database-level cascade via `ON DELETE CASCADE` foreign key constraints. The PostgreSQL implementation should not make explicit calls to delete exceptions/overrides when deleting a recurrence—the database handles this automatically.

#### 6.2.4 Auto-Migration (Hangfire Approach)
- **Strategy**: Check schema version, apply migrations on startup
- **Implementation**:
  - Embedded SQL scripts in assembly
  - Version tracking in metadata table: `CREATE TABLE __recurring_things_schema (version INT)`
  - Execute migrations sequentially if current version < target version
- **Schema creation**: Auto-create schema if missing (tables, indexes, constraints)
- **Database creation**: Database must exist (not auto-created)

---

## 7. Transaction Support

### 7.1 Integration with Transactional Library

#### 7.1.1 Transaction Context
- **Type**: `ITransactionContext?` (from Transactional.Abstractions)
- **Behavior**: Optional parameter on all engine methods
- **Null handling**: When null, operations execute without transaction

#### 7.1.2 MongoDB Transactions
- **Implementation**: `IMongoTransactionContext` wraps `IClientSessionHandle`
- **Registration**: `UseMongoDb()` internally calls `AddMongoDbTransactionManager()`
- **Usage**: Pass session to MongoDB operations

#### 7.1.3 PostgreSQL Transactions
- **Implementation**: `IPostgresTransactionContext` wraps `NpgsqlTransaction`
- **Registration**: `UsePostgreSQL()` internally calls `AddPostgresTransactionManager()`
- **Usage**: Set transaction on commands

#### 7.1.4 User Workflow
```csharp
// User creates transaction via transaction manager
var transactionManager = serviceProvider.GetRequiredService<IMongoTransactionManager>();
await using var context = await transactionManager.BeginTransactionAsync();

try
{
    // Pass context to engine operations
    await engine.CreateRecurrenceAsync(request, context);
    await engine.CreateOccurrenceAsync(request2, context);
    
    await context.CommitAsync();
}
catch
{
    await context.RollbackAsync();
    throw;
}
```

---

## 8. Validation Requirements

### 8.1 Core Library Validations

#### 8.1.1 Field Length Constraints
| Field | Min | Max | Validation Location |
|-------|-----|-----|---------------------|
| Organization | 0 | 100 | Core library |
| ResourcePath | 0 | 100 | Core library |
| Type | 1 | 100 | Core library |
| RRule | 1 | 2000 | Core library |
| TimeZone | 1 | 100 | Core library |
| Extension Key | 1 | 100 | Core library |
| Extension Value | 0 | 1024 | Core library |

#### 8.1.2 Null Constraints
- **Non-nullable strings**: Organization, ResourcePath, Type, RRule, TimeZone
- **Empty string allowed**: Organization, ResourcePath
- **Empty string not allowed**: Type, RRule, TimeZone

#### 8.1.3 Business Rule Validations
- `types` parameter: Empty array throws `ArgumentException`
- Immutable field modification: Throws `InvalidOperationException`
- Restore on clean occurrence: Throws `InvalidOperationException`
- Restore on recurrence/standalone: Throws `InvalidOperationException`
- Exception + Override on same occurrence: Prevented by repository logic
- RRule with COUNT: Throws `ArgumentException`
- RRule without UNTIL: Throws `ArgumentException`
- RRule UNTIL not in UTC: Throws `ArgumentException`
- RecurrenceEndTimeUtc not matching RRule UNTIL: Throws `ArgumentException`
- Exception/Override for recurrence in different scope: Throws `InvalidOperationException`

### 8.2 Database Layer Validations

#### 8.2.1 PostgreSQL Schema Constraints
- Column sizes match field length constraints
- NOT NULL constraints on required fields
- Foreign key constraints with CASCADE delete

---

## 9. Testing Requirements

### 9.1 Unit Tests (RecurringThings.Tests)

#### 9.1.1 Framework and Tools
- **Framework**: xUnit
- **Mocking**: Moq
- **Coverage Target**: 90%+ code coverage

#### 9.1.2 Test Categories

**Validation Tests**
- Field length constraints (all fields)
- Null constraint violations
- Empty array type filter throws exception
- Extensions key/value length validation
- RRule COUNT rejection
- RRule UNTIL requirement
- RRule UNTIL must be UTC
- RecurrenceEndTimeUtc/UNTIL mismatch
- Immutable field modification rejection
- Exception/Override tenant isolation

**State Transition Tests**
- Update allowed/disallowed scenarios (per state transition table)
- Delete allowed/disallowed scenarios (per state transition table)
- Restore allowed/disallowed scenarios (per state transition table)

**Virtualization Tests**
- Basic recurrence generation (daily, weekly, monthly, yearly)
- Exception application (occurrence removed from results)
- Override application (occurrence modified)
- Override with moved time (in range by time range overlap only)
- Override with moved time (in range by originalTimeUtc only)
- Override + delete (override removed, exception created at original time)
- Boundary conditions (query range intersections)
- Empty results when no matches
- Type filtering (null, single type, multiple types)
- Long duration entries correctly included in queries

**Time Zone Tests**
- DST spring forward (2 AM → 3 AM)
- DST fall back (2 AM → 1 AM)
- Cross-timezone recurrences
- IANA timezone validation

**Edge Cases**
- Recurrence with zero occurrences in range
- Overlapping recurrences
- Override original values are denormalized correctly
- EndTime correctly computed from StartTime + Duration
- EndTime correctly recomputed on update

#### 9.1.3 Mock Strategy
- Mock `IRecurrenceRepository`, `IOccurrenceRepository`, `IOccurrenceExceptionRepository`, `IOccurrenceOverrideRepository`
- Verify repository calls with expected parameters
- Setup return values for test scenarios

### 9.2 Integration Tests

#### 9.2.1 MongoDB Tests (RecurringThings.MongoDB.Tests)

**Setup**
- Read `MONGODB_CONNECTION_STRING` environment variable
- Create unique database per test run (append timestamp)
- Drop database after all tests complete

**Test Scenarios**
- CRUD operations on all entity types
- Transaction support (commit/rollback)
- Index creation verification
- Sharding key query patterns
- Extensions storage/retrieval
- Parallel query execution
- Cascade delete atomicity

#### 9.2.2 PostgreSQL Tests (RecurringThings.PostgreSQL.Tests)

**Setup**
- Read `POSTGRES_CONNECTION_STRING` environment variable
- Create unique schema per test run (append timestamp)
- Drop schema after all tests complete

**Test Scenarios**
- CRUD operations on all entity types
- Transaction support (commit/rollback)
- Schema migration (version tracking)
- Foreign key cascade deletes
- Extensions storage/retrieval (JSONB)

#### 9.2.3 Integration Test Exclusions
- **Not testing**: Full engine virtualization logic (covered by unit tests)
- **Focus**: Database persistence layer only

### 9.3 CI/CD Testing

#### 9.3.1 GitHub Actions Workflow
```yaml
- Run unit tests (always)
- Run integration tests (requires MONGODB_CONNECTION_STRING and POSTGRES_CONNECTION_STRING secrets)
- Run `dotnet format --verify-no-changes`
- All must pass before merge
```

#### 9.3.2 Test Execution on Feature Development
- Every PR triggers full test suite
- Feature branches cannot merge until all tests pass
- Code formatting violations block merge

---

## 10. Documentation Requirements

### 10.1 README.md Structure

#### 10.1.1 Sections
1. **Overview**: Product description, value proposition
2. **Installation**: NuGet package installation commands
3. **Quick Start**: Minimal setup example (MongoDB and PostgreSQL)
4. **Configuration**: Detailed DI registration options
5. **Usage Examples**:
   - Creating recurrences
   - Creating standalone occurrences
   - Querying occurrences (streaming with IAsyncEnumerable)
   - Updating occurrences (standalone vs virtualized)
   - Deleting occurrences (standalone vs virtualized)
   - Restoring overridden occurrences
   - Using transactions
6. **Domain Model**: Entity descriptions and relationships
7. **Immutability Rules**: Which fields can/cannot be modified
8. **State Transition Rules**: Tables showing allowed operations
9. **RRule Requirements**: UNTIL required (must be UTC), COUNT not supported
10. **Time Zone Handling**: DST examples, IANA timezone usage
11. **Multi-Tenancy**: Organization and ResourcePath usage patterns
12. **Contributing**: Development setup, testing, code formatting
13. **License**: Apache 2.0

#### 10.1.2 Update Frequency
- README updated with each new feature before PR merge
- Examples validated against actual code
- Architecture diagrams updated if structure changes

### 10.2 XML Documentation

#### 10.2.1 Requirements
- All public types have `<summary>` tags
- All public methods have `<summary>`, `<param>`, `<returns>`, `<exception>` tags
- Complex behaviors documented with `<remarks>` and code examples

#### 10.2.2 Code Example Format
```csharp
/// <summary>
/// Updates a calendar entry.
/// </summary>
/// <remarks>
/// Behavior varies by entry type:
/// <list type="bullet">
/// <item>Recurrence: Updates Duration and Extensions only</item>
/// <item>Standalone: Updates StartTime, Duration, and Extensions (recomputes EndTime)</item>
/// <item>Recurrence occurrence: Creates or updates an override (recomputes EndTime)</item>
/// </list>
/// 
/// Immutable fields (Organization, ResourcePath, Type, TimeZone, and for recurrences:
/// StartTime, RRule, RecurrenceEndTime) cannot be modified. Attempting to change
/// these throws InvalidOperationException.
/// </remarks>
/// <exception cref="InvalidOperationException">
/// Thrown when attempting to modify immutable fields
/// </exception>
```

---

## 11. Code Quality Requirements

### 11.1 Formatting

#### 11.1.1 EditorConfig
- Use standard .NET EditorConfig
- 4 spaces for indentation
- LF line endings
- UTF-8 encoding

#### 11.1.2 dotnet format
- Run `dotnet format` after completing each feature
- CI/CD enforces `dotnet format --verify-no-changes`
- No merge allowed if formatting violations exist

### 11.2 Code Analysis

#### 11.2.1 Analyzer Rules
- Enable all Roslyn analyzers
- Treat warnings as errors in Release builds
- Nullable reference types enabled (`<Nullable>enable</Nullable>`)

### 11.3 Performance

#### 11.3.1 Optimization Targets
- Minimize allocations in hot paths (virtualization loop)
- Use `ValueTask` where appropriate
- Avoid LINQ in performance-critical sections
- Reuse collections where possible
- Execute independent database queries in parallel
- Stream results via IAsyncEnumerable to avoid materializing large result sets

#### 11.3.2 Benchmarking
- **Status**: No benchmark tests maintained in v1.0
- **Future**: May add in v2.0 if performance concerns arise

---

## 12. Versioning and Release Strategy

### 12.1 Semantic Versioning

#### 12.1.1 Version Format
- **Pattern**: `vMAJOR.MINOR.PATCH[-SUFFIX.NUMBER]`
- **Major**: Aligned with .NET target framework (v10.x.x for .NET 10)
- **Minor**: New features, backwards compatible
- **Patch**: Bug fixes, backwards compatible
- **Suffix**: Prerelease identifier (`alpha`, `beta`, `rc`)

#### 12.1.2 Examples
- `v10.0.0`: First stable release for .NET 10
- `v10.1.0`: New feature (e.g., add prefix matching for ResourcePath)
- `v10.1.1`: Bug fix
- `v10.2.0-beta.1`: Prerelease for upcoming feature

### 12.2 Git Workflow

#### 12.2.1 Branch Strategy
- **main**: Protected, single source of truth
- **feature/[name]**: Temporary branches for development
- **No long-lived branches**: All features merge to main after approval

#### 12.2.2 Pull Request Process
1. Create feature branch from main
2. Implement feature with tests and documentation
3. Run `dotnet format`
4. Create PR to main
5. Code review and approval
6. Merge and delete feature branch
7. **No automatic publishing**

### 12.3 Publishing

#### 12.3.1 Prerelease
1. Ensure main is up to date
2. Create annotated tag: `git tag -a v10.1.0-beta.1 -m "Beta release"`
3. Push tag: `git push origin v10.1.0-beta.1`
4. GitHub Action triggers automatically
5. Package published to NuGet.org with prerelease flag

#### 12.3.2 Stable Release
1. Ensure main is up to date
2. Create annotated tag: `git tag -a v10.1.0 -m "Stable release"`
3. Push tag: `git push origin v10.1.0`
4. GitHub Action triggers automatically
5. Package published to NuGet.org as stable

### 12.4 CI/CD Workflow

#### 12.4.1 GitHub Action (`.github/workflows/publish.yml`)

**Trigger**: Push of tag matching `v[0-9]+.[0-9]+.[0-9]+*`

**Steps**:
1. Checkout repository
2. Setup .NET 10 SDK
3. Extract version from tag (remove `refs/tags/v`)
4. Build and pack all three projects:
   - `dotnet pack RecurringThings -c Release /p:Version={version}`
   - `dotnet pack RecurringThings.MongoDB -c Release /p:Version={version}`
   - `dotnet pack RecurringThings.PostgreSQL -c Release /p:Version={version}`
5. Push packages to NuGet.org using `NUGET_API_KEY` secret
6. Use `--skip-duplicate` to prevent errors on re-runs

#### 12.4.2 Project Configuration

**Required in all .csproj files**:
```xml
<PropertyGroup>
    <PackageId>RecurringThings</PackageId>
    <Authors>YourName</Authors>
    <Description>Package description</Description>
    <RepositoryUrl>https://github.com/ChuckNovice/RecurringThings</RepositoryUrl>
    <PackageLicenseExpression>Apache-2.0</PackageLicenseExpression>
    <TargetFramework>net10.0</TargetFramework>
    <!-- NO <Version> element - set dynamically via /p:Version -->
</PropertyGroup>
```

### 12.5 Unified Versioning
- All three packages (RecurringThings, RecurringThings.MongoDB, RecurringThings.PostgreSQL) use identical version numbers
- Single tag triggers publishing of all three packages
- Example: `v10.1.0` publishes all three as `10.1.0`

---

## 13. Out of Scope for v1.0

### 13.1 Explicitly Excluded Features

#### 13.1.1 Query Features
- Prefix/wildcard matching on ResourcePath
- Full-text search on Extensions
- Pagination on GetAsync results
- Sorting options

#### 13.1.2 Recurrence Features
- RRule with COUNT (only UNTIL supported)
- Recurrence templates/presets
- Bulk operations (create/update/delete multiple)
- Optimistic concurrency (removed from scope)

#### 13.1.3 UI/Client Features
- REST API layer
- GraphQL API
- Client SDKs
- Admin dashboard

#### 13.1.4 Advanced Persistence
- Elasticsearch integration
- Redis caching layer
- Event sourcing
- Change data capture

#### 13.1.5 Operational Features
- Metrics/telemetry
- Health checks
- Rate limiting
- Audit logging (beyond user-defined Extensions)

### 13.2 Potential Future Enhancements (v2.0+)
- Additional database providers (SQL Server, SQLite)
- Advanced querying (GraphQL, OData)
- Performance benchmarking suite
- Caching layer for frequently accessed recurrences
- Batch operations API
- Optimistic concurrency support

---

## 14. Design Decisions

This section documents intentional design decisions that are final and should not be revisited.

### 14.1 No Conflict Detection
Two recurrences can create overlapping occurrences. Two users can simultaneously override the same occurrence to different times. This library does not implement optimistic concurrency or conflict detection. Consumers must implement their own conflict detection if needed.

### 14.2 No Query Result Limits
`GetAsync()` does not enforce a maximum number of results. If a consumer queries a 10-year range with a daily recurrence, they will receive 3,650+ virtualized occurrences streamed via `IAsyncEnumerable`. It is the consumer's responsibility to validate query ranges at their API boundaries to prevent excessive queries.

### 14.3 No Distributed Lock for Index Creation
MongoDB auto-migration creates indexes on first operation if missing. In multi-replica deployments, this may result in concurrent index creation attempts. MongoDB handles this gracefully with duplicate key errors that are safely ignored. No distributed locking is implemented.

### 14.4 No "Now" Timestamps
This library never uses the current system time. All DateTime values are provided by the user and are deterministic. Clock skew between distributed systems is not a concern because timestamps always originate from user input (e.g., form submissions).

### 14.5 No Protection Against Direct Database Modification
The library stores `RecurrenceEndTime` as a denormalized copy of the RRule UNTIL value. These must stay in sync. If someone directly modifies the database and desyncs these values, behavior is undefined. The library is not designed to protect against manual database corruption.

### 14.6 No Restoring Excepted Occurrences
Once an occurrence is deleted (an exception is created), it cannot be restored through the API. Excepted occurrences are not returned by `GetAsync()`, so there is no `CalendarEntry` to pass to `RestoreAsync()`. This is intentional—deletion is permanent for recurrence occurrences.

### 14.7 Database-Specific Cascade Delete Implementation
MongoDB uses application-level cascade deletes within a transaction to ensure atomicity. PostgreSQL uses database-level `ON DELETE CASCADE` foreign key constraints and skips explicit cascade delete calls. Each database implementation handles this appropriately.

---

## 15. Success Criteria

### 15.1 Functional Success
- ✅ All core operations work correctly (create, update, delete, restore, query)
- ✅ Virtualization generates correct occurrences with exceptions and overrides
- ✅ Time zones and DST handled correctly
- ✅ Multi-tenancy isolation verified
- ✅ Transactions work correctly with Transactional library
- ✅ Immutability rules enforced
- ✅ RRule UNTIL validation working (UTC requirement enforced)
- ✅ EndTime correctly computed and recomputed on updates

### 15.2 Quality Success
- ✅ 90%+ unit test coverage
- ✅ All integration tests pass
- ✅ Zero code formatting violations
- ✅ All XML documentation complete
- ✅ README comprehensive and accurate

### 15.3 Performance Success
- ✅ GetAsync streams results efficiently via IAsyncEnumerable
- ✅ MongoDB queries use appropriate indexes
- ✅ PostgreSQL queries use appropriate indexes
- ✅ No N+1 query issues
- ✅ Parallel query execution for independent data fetches

### 15.4 Developer Experience Success
- ✅ Simple DI registration (single `AddRecurringThings()` call)
- ✅ Intuitive API (no repository exposure, unified CalendarEntry abstraction)
- ✅ Clear error messages for illegal operations
- ✅ Comprehensive examples in README

---

## 16. Appendices

### 16.1 State Transition Reference Table

| Operation | Entry Type | Override | Result |
|-----------|------------|----------|--------|
| **Update** | Recurrence | - | Update Duration/Extensions only |
| | Standalone | - | Update StartTime/Duration/Extensions, recompute EndTime |
| | Recurrence Occ | No | Create override (denormalize originals) |
| | Recurrence Occ | Yes | Update override, recompute EndTime |
| **Delete** | Recurrence | - | Delete series + all exceptions/overrides (in transaction for MongoDB) |
| | Standalone | - | Direct delete |
| | Recurrence Occ | No | Create exception |
| | Recurrence Occ | Yes | Delete override, create exception |
| **Restore** | Recurrence | - | **Error** |
| | Standalone | - | **Error** |
| | Recurrence Occ | No | **Error** |
| | Recurrence Occ | Yes | Delete override |

### 16.2 Repository Interface Signatures

```csharp
public interface IRecurrenceRepository
{
    Task<Recurrence> CreateAsync(
        Recurrence recurrence, 
        ITransactionContext? context);
    
    Task<Recurrence> UpdateAsync(
        Recurrence recurrence, 
        ITransactionContext? context);
    
    Task DeleteAsync(
        Guid id, 
        string organization, 
        string resourcePath, 
        ITransactionContext? context);
    
    IAsyncEnumerable<Recurrence> GetInRangeAsync(
        string organization,
        string resourcePath,
        DateTime startUtc,
        DateTime endUtc,
        string[]? types,
        ITransactionContext? context,
        [EnumeratorCancellation] CancellationToken cancellationToken = default);
}

// Similar interfaces for IOccurrenceRepository, 
// IOccurrenceExceptionRepository, IOccurrenceOverrideRepository
```

### 16.3 MongoDB Query Example

Two parallel queries:

**Query 1: Recurrences and Occurrences**
```javascript
db.recurring_things.find({
  organization: "tenant1",
  resourcePath: "user123/calendar",
  documentType: { $in: ["recurrence", "occurrence"] },
  type: { $in: ["appointment", "meeting"] },
  $or: [
    { 
      documentType: "occurrence", 
      startTime: { $lte: ISODate("2025-01-31") },
      endTime: { $gte: ISODate("2025-01-01") }
    },
    { 
      documentType: "recurrence", 
      startTime: { $lte: ISODate("2025-01-31") },
      recurrenceEndTime: { $gte: ISODate("2025-01-01") }
    }
  ]
})
```

**Query 2: Exceptions and Overrides**
```javascript
db.recurring_things.find({
  organization: "tenant1",
  resourcePath: "user123/calendar",
  documentType: { $in: ["exception", "override"] },
  $or: [
    { originalTimeUtc: { $gte: ISODate("2025-01-01"), $lte: ISODate("2025-01-31") } },
    { startTime: { $lte: ISODate("2025-01-31") }, endTime: { $gte: ISODate("2025-01-01") } }
  ]
})
```

### 16.4 PostgreSQL Query Example

```sql
-- Query 1: Get recurrences
SELECT * FROM recurrences
WHERE organization = 'tenant1'
  AND resource_path = 'user123/calendar'
  AND type IN ('appointment', 'meeting')
  AND start_time <= '2025-01-31'
  AND recurrence_end_time >= '2025-01-01';

-- Query 2: Get standalone occurrences
SELECT * FROM occurrences
WHERE organization = 'tenant1'
  AND resource_path = 'user123/calendar'
  AND type IN ('appointment', 'meeting')
  AND start_time <= '2025-01-31'
  AND end_time >= '2025-01-01';

-- Query 3: Get exceptions
SELECT * FROM occurrence_exceptions
WHERE organization = 'tenant1'
  AND resource_path = 'user123/calendar'
  AND original_time_utc BETWEEN '2025-01-01' AND '2025-01-31';

-- Query 4: Get overrides (by original time OR new time range)
SELECT * FROM occurrence_overrides
WHERE organization = 'tenant1'
  AND resource_path = 'user123/calendar'
  AND (original_time_utc BETWEEN '2025-01-01' AND '2025-01-31'
       OR (start_time <= '2025-01-31' AND end_time >= '2025-01-01'));
```